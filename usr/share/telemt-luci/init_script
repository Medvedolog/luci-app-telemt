#!/bin/sh /etc/rc.common
# ==============================================================================
# Telemt Init Script (Config Generator & Procd Wrapper)
# Version: 3.1.2-7 (Upstream Master Switch)
# ==============================================================================

USE_PROCD=1
START=99
STOP=10

CONF="telemt"
TMP_CONF="/var/etc/telemt.toml"
VERSION_FILE="/var/etc/telemt.version"
STATS_FILE="/tmp/telemt_stats.txt"

# Helper: IP Calc fallback for LAN whitelist
_ipcalc_network() {
    if command -v ipcalc >/dev/null 2>&1; then
        ipcalc -n "$1/$2" 2>/dev/null | awk -F= '/^NETWORK/{print $2}'
    elif [ -x /bin/ipcalc.sh ]; then
        /bin/ipcalc.sh "$1" "$2" 2>/dev/null | awk -F= '/^NETWORK/{print $2}'
    fi
}

_ipcalc_prefix() {
    if command -v ipcalc >/dev/null 2>&1; then
        ipcalc -p "$1/$2" 2>/dev/null | awk -F= '/^PREFIX/{print $2}'
    elif [ -x /bin/ipcalc.sh ]; then
        /bin/ipcalc.sh "$1" "$2" 2>/dev/null | awk -F= '/^PREFIX/{print $2}'
    fi
}

# ==============================================================================
# Upstream Handler (Routing Chain array)
# ==============================================================================
has_upstreams=0

handle_upstream() {
    local cfg="$1"
    local enabled type address username password weight
    
    config_get_bool enabled "$cfg" "enabled" 1
    [ "$enabled" -eq 1 ] || return 0
    
    config_get type "$cfg" "type" "socks5"
    config_get weight "$cfg" "weight" "10"
    
    echo "[[upstreams]]" >> "$TMP_CONF"
    echo "type = \"$type\"" >> "$TMP_CONF"
    echo "weight = $weight" >> "$TMP_CONF"
    
    if [ "$type" != "direct" ]; then
        config_get address "$cfg" "address" ""
        [ -n "$address" ] && echo "address = \"$address\"" >> "$TMP_CONF"
        
        if [ "$type" = "socks5" ]; then
            config_get username "$cfg" "username" ""
            config_get password "$cfg" "password" ""
            [ -n "$username" ] && echo "username = \"$username\"" >> "$TMP_CONF"
            [ -n "$password" ] && echo "password = \"$password\"" >> "$TMP_CONF"
        fi
    fi
    echo "" >> "$TMP_CONF"
    has_upstreams=1
}

# ==============================================================================
# User Handler
# ==============================================================================
handle_user() {
    local cfg="$1"
    local secret max_conns max_ips quota exp
    
    config_get secret "$cfg" "secret" ""
    [ -z "$secret" ] && return 0
    
    config_get max_conns "$cfg" "max_tcp_conns" ""
    config_get max_ips "$cfg" "max_unique_ips" ""
    config_get quota "$cfg" "data_quota" ""
    config_get exp "$cfg" "expire_date" ""
    
    echo "[[users]]" >> "$TMP_CONF"
    echo "name = \"$cfg\"" >> "$TMP_CONF"
    echo "secret = \"$secret\"" >> "$TMP_CONF"
    [ -n "$max_conns" ] && echo "max_tcp_conns = $max_conns" >> "$TMP_CONF"
    [ -n "$max_ips" ] && echo "max_unique_ips = $max_ips" >> "$TMP_CONF"
    [ -n "$quota" ] && echo "data_quota = $quota" >> "$TMP_CONF"
    [ -n "$exp" ] && echo "expire_date = \"$exp\"" >> "$TMP_CONF"
    echo "" >> "$TMP_CONF"
}

generate_config() {
    config_load "$CONF"
    
    local enabled
    config_get_bool enabled general enabled 0
    [ "$enabled" -eq 1 ] || return 1
    
    # Securing TOML generation
    umask 077
    mkdir -p /var/etc
    rm -f "$TMP_CONF"
    touch "$TMP_CONF"
    chmod 600 "$TMP_CONF"
    
    # --- Server Block ---
    local port log_level domain mode
    config_get port general port 4443
    config_get log_level general log_level "normal"
    config_get domain general domain "google.com"
    config_get mode general mode "tls"
    
    echo "[server]" >> "$TMP_CONF"
    echo "port = $port" >> "$TMP_CONF"
    echo "log_level = \"$log_level\"" >> "$TMP_CONF"
    
    # --- Listeners ---
    local listen_ipv4 listen_ipv6
    config_get_bool listen_ipv4 advanced listen_ipv4 1
    config_get_bool listen_ipv6 advanced listen_ipv6 0
    
    if [ "$listen_ipv4" -eq 1 ]; then
        echo "[[server.listeners]]" >> "$TMP_CONF"
        echo "addr = \"0.0.0.0:$port\"" >> "$TMP_CONF"
    fi
    if [ "$listen_ipv6" -eq 1 ]; then
        echo "[[server.listeners]]" >> "$TMP_CONF"
        echo "addr = \"[::]:$port\"" >> "$TMP_CONF"
    fi
    echo "" >> "$TMP_CONF"
    
    # --- Metrics ---
    local mport m_lo m_lan m_wl
    config_get mport advanced metrics_port 9091
    config_get_bool m_lo advanced metrics_allow_lo 1
    config_get_bool m_lan advanced metrics_allow_lan 1
    config_get m_wl advanced metrics_whitelist ""
    
    echo "metrics_port = $mport" >> "$TMP_CONF"
    
    local wl_array=""
    [ "$m_lo" -eq 1 ] && wl_array="\"127.0.0.1/32\", \"::1/128\""
    if [ "$m_lan" -eq 1 ]; then
        . /lib/functions/network.sh
        local ipaddr netmask
        network_get_ipaddr ipaddr "lan"
        network_get_subnet netmask "lan"
        if [ -n "$ipaddr" ] && [ -n "$netmask" ]; then
            local net=$(_ipcalc_network "$ipaddr" "$netmask")
            local pfx=$(_ipcalc_prefix "$ipaddr" "$netmask")
            if [ -n "$net" ] && [ -n "$pfx" ]; then
                [ -n "$wl_array" ] && wl_array="$wl_array, "
                wl_array="$wl_array\"$net/$pfx\""
            fi
        fi
    fi
    if [ -n "$m_wl" ]; then
        for cidr in $(echo "$m_wl" | tr ',' ' '); do
            [ -n "$wl_array" ] && wl_array="$wl_array, "
            wl_array="$wl_array\"$cidr\""
        done
    fi
    if [ -n "$wl_array" ]; then
        echo "metrics_whitelist = [$wl_array]" >> "$TMP_CONF"
    fi
    echo "" >> "$TMP_CONF"
    
    # --- Upstreams Parsing (With Master Switch) ---
    local en_up
    config_get_bool en_up general enable_upstreams 0
    has_upstreams=0
    
    if [ "$en_up" -eq 1 ]; then
        config_foreach handle_upstream upstream
    fi
    
    # Fallback to direct routing if master switch is off OR list is empty
    if [ "$has_upstreams" -eq 0 ]; then
        echo "[[upstreams]]" >> "$TMP_CONF"
        echo "type = \"direct\"" >> "$TMP_CONF"
        echo "weight = 10" >> "$TMP_CONF"
        echo "" >> "$TMP_CONF"
    fi
    
    # --- Network Routing ---
    local pref_ip
    config_get pref_ip advanced prefer_ip 4
    echo "[network]" >> "$TMP_CONF"
    echo "prefer_ip = $pref_ip" >> "$TMP_CONF"
    
    local use_mp stun
    config_get_bool use_mp advanced use_middle_proxy 0
    if [ "$use_mp" -eq 1 ]; then
        config_get_bool stun advanced use_stun 1
        local mpool mwarm mhard mdrain adeg mdc
        config_get mpool advanced me_pool_size 16
        config_get mwarm advanced me_warm_standby 8
        config_get_bool mhard advanced hardswap 1
        config_get mdrain advanced me_drain_ttl 90
        config_get_bool adeg advanced auto_degradation 1
        config_get mdc advanced degradation_min_dc 2
        
        echo "use_middle_proxy = true" >> "$TMP_CONF"
        [ "$stun" -eq 1 ] && echo "middle_proxy_nat_probe = true" >> "$TMP_CONF" || echo "middle_proxy_nat_probe = false" >> "$TMP_CONF"
        echo "me_pool_size = $mpool" >> "$TMP_CONF"
        echo "me_warm_standby = $mwarm" >> "$TMP_CONF"
        [ "$mhard" -eq 1 ] && echo "hardswap = true" >> "$TMP_CONF" || echo "hardswap = false" >> "$TMP_CONF"
        echo "me_drain_ttl = $mdrain" >> "$TMP_CONF"
        [ "$adeg" -eq 1 ] && echo "auto_degradation = true" >> "$TMP_CONF" || echo "auto_degradation = false" >> "$TMP_CONF"
        echo "degradation_min_dc = $mdc" >> "$TMP_CONF"
    else
        echo "use_middle_proxy = false" >> "$TMP_CONF"
    fi
    echo "" >> "$TMP_CONF"
    
    # --- Censorship & Masking ---
    echo "[censorship]" >> "$TMP_CONF"
    local d_all fcl ttls mpp
    config_get_bool d_all advanced desync_all_full 0
    config_get fcl advanced fake_cert_len 2048
    config_get ttls advanced tls_full_cert_ttl_secs 90
    config_get mpp advanced mask_proxy_protocol 0
    
    [ "$d_all" -eq 1 ] && echo "desync_all_full = true" >> "$TMP_CONF"
    echo "fake_cert_len = $fcl" >> "$TMP_CONF"
    echo "tls_full_cert_ttl_secs = $ttls" >> "$TMP_CONF"
    echo "mask_proxy_protocol = $mpp" >> "$TMP_CONF"
    
    if [ "$mode" = "tls" ] || [ "$mode" = "all" ]; then
        echo "tls_domain = \"$domain\"" >> "$TMP_CONF"
        echo "mask_host = \"$domain:443\"" >> "$TMP_CONF"
    fi
    echo "" >> "$TMP_CONF"
    
    # --- Timeouts ---
    echo "[timeouts]" >> "$TMP_CONF"
    local t_h t_c t_k t_a rw
    config_get t_h advanced tm_handshake 15
    config_get t_c advanced tm_connect 10
    config_get t_k advanced tm_keepalive 60
    config_get t_a advanced tm_ack 300
    config_get rw advanced replay_window_secs 1800
    echo "client_handshake = $t_h" >> "$TMP_CONF"
    echo "telegram_connect = $t_c" >> "$TMP_CONF"
    echo "client_keepalive = $t_k" >> "$TMP_CONF"
    echo "client_ack = $t_a" >> "$TMP_CONF"
    echo "replay_window_secs = $rw" >> "$TMP_CONF"
    echo "" >> "$TMP_CONF"
    
    # --- Users ---
    config_foreach handle_user user
    
    return 0
}

run_save_stats() {
    pidof telemt >/dev/null || return 0
    local mport
    config_load "$CONF"
    config_get mport advanced metrics_port 9091
    
    local get_cmd="wget -q -O -"
    command -v uclient-fetch >/dev/null 2>&1 && get_cmd="uclient-fetch -q -O -"
    
    local stats=$($get_cmd "http://127.0.0.1:$mport/metrics" 2>/dev/null | grep -E '^telemt_user_octets_from_client|^telemt_user_octets_to_client|^telemt_accumulated')
    [ -z "$stats" ] && return 0
    
    local awk_script='
    BEGIN { FS=" "; }
    {
        if (NR==FNR) { acc_tx[$1] = $2; acc_rx[$1] = $3; } 
        else {
            if (match($0, /user="([^"]+)"/, arr)) {
                u = arr[1]; val = $NF;
                if ($1 ~ /telemt_user_octets_to_client/) live_tx[u] += val;
                else if ($1 ~ /telemt_user_octets_from_client/) live_rx[u] += val;
                else if ($1 ~ /telemt_accumulated_tx/) base_tx[u] = val;
                else if ($1 ~ /telemt_accumulated_rx/) base_rx[u] = val;
            }
        }
    }
    END {
        for (u in live_tx) {
            total_tx = live_tx[u] + (base_tx[u] ? base_tx[u] : acc_tx[u]);
            total_rx = live_rx[u] + (base_rx[u] ? base_rx[u] : acc_rx[u]);
            print u " " (total_tx ? total_tx : 0) " " (total_rx ? total_rx : 0);
        }
    }'
    
    local new_stats
    if [ -f "$STATS_FILE" ]; then new_stats=$(echo "$stats" | awk "$awk_script" "$STATS_FILE" -)
    else new_stats=$(echo "$stats" | awk "$awk_script" /dev/null -); fi
    
    [ -n "$new_stats" ] && echo "$new_stats" > "$STATS_FILE"
}

start_service() {
    generate_config || return 1
    
    local bin="/usr/bin/telemt"
    [ -x "$bin" ] || bin=$(command -v telemt)
    [ -x "$bin" ] || return 1
    
    $bin --version 2>/dev/null | awk '{print $2}' > "$VERSION_FILE"
    
    procd_open_instance
    procd_set_param command "$bin" --config "$TMP_CONF"
    procd_set_param file "$TMP_CONF"
    procd_set_param respawn 3600 30 0
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_close_instance
    
    local afw port
    config_get_bool afw general auto_fw 0
    config_get port general port 4443
    if [ "$afw" -eq 1 ]; then
        procd_open_data
        json_add_array firewall
        json_add_object ""
        json_add_string type rule
        json_add_string name "Allow-Telemt-Magic"
        json_add_string src "*"
        json_add_string dest_port "$port"
        json_add_string proto tcp
        json_add_string target ACCEPT
        json_close_object
        json_close_array
        procd_close_data
    fi
}

stop_service() {
    run_save_stats 2>/dev/null
}

service_triggers() {
    procd_add_reload_trigger "telemt"
}

EXTRA_COMMANDS="run_save_stats"
